package ProtobufPacket;

//战斗事件，战斗内部产生的事件
//不使用继承，因此用这种冗余的写法，通过type，区分类型，然后去使用某个字段
//对于pb流本身，不对字段赋值，是没有额外的浪费
//对于目前C#版本的pb对象，还是会new出来各个字段的对象，有一些浪费
//对于C++版本的pb对象，不赋值，不会创建对象出来，没有浪费
//并且这个pb对象不会保存，只是一次性的创建后消耗
message BattleEvent
{
	required int32 type = 1;

	optional UseSkillEvent skillEvent = 2;
	optional HitEvent hitEvent = 3;
	optional RoundAPEvent roundAPEvent = 4;
	optional ImpactsChangeEvent impactsChangeEvent = 5;
	optional KillRoleEvent killRoleEvent = 6;
	optional ChangeSpiritEvent changeSpiritEvent = 7;
	optional ChangeEnvEvent changeEnvEvent = 8;
	optional DeleteRoleEvent deleteRoleEvent = 9;
	optional AddRoleEvent addRoleEvent = 10;
	optional SyncBattleState syncEvent = 11;
	optional RoundBeginEvent roundBeginEvent = 12;
	optional RoundEvent roundEvent = 13;
	optional WaveStartEvent waveStartEvent = 15;
	optional WaveEndEvent waveEndEvent = 16;
	optional PrepareEvent prepareEvent = 17;
	optional DropItemEvent dropItemEvent = 18;
	optional PlayCutsceneEvent playCutsceneEvent = 19;
	optional IdleEvent idleEvent = 20;
	optional ScenarioEvent scenarioEvent = 21;
	optional RoleActionEvent roleActionEvent = 22;
	optional PlayStoryContentEvent playStoryContentEvent = 23;
	optional SkillCooldownChangeEvent skillCooldownEvent = 24;
	optional NoticeEvent noticeEvent = 25;
	optional ChangeSkillsEvent changeSkillsEvent = 27;
	optional ParallelEvent parallelEvent = 28;
	optional BubbleEvent bubbleEvent = 29;
	optional BattleStartEvent battleStartEvent = 30;
	//之前事件加的有点多，很多逻辑事件本来都应该用hit做的
	//之后的逻辑触发技能，效果（怒气，打断等等）的事件，统一用hit事件做
}

message HitResult
{
	optional int32 targetID = 1;
	repeated BattleEvent events = 2;
}

//平行事件，所有的事件会并行执行
message ParallelEvent
{
	repeated BattleEvent events = 1;
}

message Hit
{
	repeated HitResult hitResults = 1;
	optional bool isAnimHit = 2;
}

message UseSkillEvent
{
	optional int32 casterID = 1;
	optional int32 targetID = 2;
	optional int32 usedSkillID = 3;
	repeated Hit hits = 4;
}

message HitEvent
{
	optional int32 senderID = 1;
	optional int32 targetID = 2;
	optional int32 hitType = 3;
	optional int32 val = 4;
	optional int32 param0 = 5;
	optional int32 param1 = 6;
}

message APChange
{
	optional int32 roleID = 1;
	optional int32 newAP = 2;
	optional int32 newActIndex = 3;
	optional bool  isWaitingAct = 4;
}

message RoundAPEvent
{
	optional int32 count = 1;
	repeated APChange apChanges = 2;
}

message ImpactInfo
{
	optional int32 impactID = 1;
	optional int32 roundCount = 2;
	optional int32 layerCount = 3;
	optional int32 senderID = 4;
	//自身的唯一id
	optional int32 id = 5;
	optional int32 duration = 6;	//持续时间
}

message ImpactsChangeEvent
{
	optional int32 ownerID = 1;
	optional int32 seq = 2;
	repeated ImpactUpdateInfo infos = 3;
}

message ImpactUpdateInfo
{
	optional int32 updateType = 1;
	optional int32 id = 2;
	optional ImpactInfo info = 3;
}

message KillRoleEvent
{
	optional int32 killerID = 1;
	optional int32 roleID = 2;
}

message DeleteRoleEvent
{
	optional int32 roleID = 1;
	optional bool isForReplace = 2;
}

message AddRoleEvent
{
	optional int32 roleID = 1;
	//初始化数据，客户端自己的战斗，这个字段可以空，服务器的战斗，这个字段是服务器赋值
	//观战，组队时，需要拿到队友的数据，目前考虑先用全数据。
	//如果压力大，可以改成rolesync，rolesync增加一个字段表示model信息
	//optional RoleInitData data = 2;
	//是否有出生表现
	optional bool isPlaySpawnAnim = 2;
	optional RoleSync sync = 3;
}

message ChangeSpiritEvent
{
	optional int32 cur = 1;
	optional int32 max = 2;
}

message ChangeEnvEvent
{
	optional int32 envID = 1;
}

//准备阶段的展示事件
message PrepareEvent
{
	//刷出来的我方角色
	repeated RoleSync blues = 1;
	//刷出来的敌方角色
	repeated RoleSync reds = 2;
	//其他需要告诉客户端特殊表现的数据
	repeated BattleEvent events = 3;
}

message BattleStartEvent
{
	optional int32 envID = 1;
	optional bool hasDefaultEnv = 2;
	optional int32 count0 = 3;
	optional int32 count1 = 4;
}

message DropItemEvent
{
	optional BattleDropItemList dropList = 1;
	optional int32 roleId = 2;
}

message PlayCutsceneEvent
{
	optional int32 id = 1;
}

message IdleEvent
{
	optional float time = 1;
}

message ScenarioEvent
{
	repeated BattleEvent events = 1;
}

message RoleActionEvent
{
	optional int32 roleId = 1;
	
	optional int32 animId = 2;
	optional int32 effectId = 3;
	optional int32 paopao = 4;
	optional float paopaoTime = 5;
}

message PlayStoryContentEvent
{
	optional int32 id = 1;
}

message BubbleAction
{
	optional int32 roleId = 1;	//喊话角色
	optional int32 type = 2;	//喊话类型

	optional BubbleAction nextBubble = 3;	//回话

	optional int32 userObjId = 4;
}

message BubbleEvent
{
	repeated BubbleAction bubbles = 1;
}

message SkillCooldownInfo
{
	optional int32 cooldownId = 1;
	optional int32 cooldownLeft = 2;
}

message SkillCooldownChangeEvent
{
	optional int32 roleId = 1;
	repeated SkillCooldownInfo skillCooldownInfos = 2;
}

message NoticeEvent
{
	optional string notice = 1;
}

message ChangeSkillsEvent
{
	optional int32 roleId = 1;
	repeated int32 skillIds = 2;
}

//角色属性
message Attr
{
	optional int32 type = 1;
	optional int32 value = 2;
}


//=====数据库使用，需要考虑兼容性=================
message Attrs
{
	repeated Attr attrs = 1;
}

//=====数据库使用，需要考虑兼容性=================
message SkillInfo
{
	optional int32 skillID = 1;
	optional int32 level = 2;
}

//创建角色时附带的外形信息
//逻辑不用，但是需要同步给客户端的，都可以放到这里
//=====数据库使用，需要考虑兼容性=================
message RoleVisualInfo
{
	optional int32 modelId = 1[default=-1];
	//其他信息....
	optional int32 talismanVisualId = 2;
	optional int32 soulWareModelId = 3;
	optional int32 dyeColorId = 4[default=-1];
	optional int32 ornamentEffect = 5[default=-1];

	//guid部分，不是所有的角色都需要，放到这里
	message _Guid
	{
		optional uint32 low = 1;
		optional uint32 high = 2;
	}

	optional _Guid cardGuid = 6;
}

//=====数据库使用，需要考虑兼容性=================
message RoleInfo
{
	optional int32 roleBaseID = 1;
	repeated SkillInfo skillInfos = 2;	//技能信息
	//装备
	//时装
	//属性值
	optional Attrs attrs = 3;
	optional bool isHeroCard = 4;
	optional int32 cardId = 6[default=-1];
	optional int32 monsterId = 7[default=-1];

	//外观形象
	optional RoleVisualInfo visualInfo = 8;

	optional int32 heroId = 9[default=-1];
}


//创建角色用的信息
message RoleInitData
{
	optional RoleInfo roleInfo = 1;
	optional int32 side = 2;
	optional int32 battlePos = 3;
	optional int32 battlePosArea = 4;
	optional RoleStatus status = 5;
	optional int32 spawnRule = 6;	//创建规则，0常规（占位已有人，则失败）,1替换，2共存

	optional int32 userObjId = 7[default=-1];	//玩家id，不是guid，是服务器分配的属于战斗的id
	optional int32 ai = 8;			//ai

	optional int32 queryId = 9;		//分配了queryId后，可以在战斗结束，通过queryId，查询角色相关信息
}

//角色状态
//提供外部修改内部战斗状态的途径
//继承上场战斗的状态(车轮战)；实时战斗状态变化(同步世界boss)
message RoleStatus
{
	optional int32 hp = 2;
	optional int32 ap = 3;

	repeated SkillCooldownInfo skillCooldowns = 4;
	repeated ImpactInfo impacts = 5;
}

//内部向外部同步的途径
//战场信息同步
message BattleSync
{
	optional int32 envID = 2;
	optional int32 spirit = 3;
	optional int32 spiritMax = 4;
	optional int32 waveIndex = 5;
	optional int32 roundCount = 6;
}

//角色信息同步
message RoleSync
{
	optional int32 roleBaseID = 1;
	
	optional int32 roleID = 2;
	optional int32 hp = 3;
	optional int32 maxHP = 4;
	optional int32 ap = 5;
	optional int32 actIndex = 6;

	optional int32 side = 7;
	optional int32 battlePos = 8;
	optional int32 battlePosArea = 9;

	repeated int32 skills = 10;
	repeated SkillCooldownInfo skillCooldowns = 11;
	repeated ImpactInfo impacts = 12;

	optional bool isHeroCard = 13;
	//optional bool canReplace = 14;

	//optional int32 level = 15;

	optional int32 cardId = 16[default=-1];
	optional int32 monsterId = 17[default=-1];

	optional Attrs fullAttrs = 18;		//完整属性

	optional int32 userObjId = 19[default=-1];		//属于哪个玩家
	optional int32 sp = 22;				//怒气
	optional bool isWaitingAct = 23;	//是否在等待行动

	//外观信息
	optional RoleVisualInfo visualInfo = 24;

	optional int32 summonOnwerId = 25;	//被召唤物，会有召唤者的id
	optional int32 heroId = 26[default=-1];

	optional int32 maxHpReduce = 27; //血上限损失
	optional int32 shiled = 28;	//护盾值
}

message SyncBattleState
{
	optional BattleSync battleSync = 1;
	repeated RoleSync roleSyncs = 2;
}
//////////////////////////////////////////////////////////////////////////////////////////////


message WaveStartEvent
{
	optional int32 waveIndex = 1;
}

message RoundBeginEvent
{
	optional int32 roundRoleID = 1;
	optional bool isNeedPlayerInput = 2;
	optional int32 roundCount = 3;
	optional int32 userObjId = 4[default=-1];
}

message RoundEvent
{
	optional int32 roundRoleID = 1;
	optional int32 roundCount = 2;
}

message WaveEndEvent
{
	optional int32 waveIndex = 1;
}

//获取战斗里的信息
message BattleStatus
{
	optional bool isWaveClear = 1;

	optional int32 winSide = 2;		//胜利方

	optional int32 waveIndex = 3;	//当前波次
	optional int32 waveMax = 4;		//最大波次

}

//battleCore内部创建的Msg，控制器直接转发
message BattleMsg
{
	repeated BattleEvent events = 1;
	optional int32 hasPause = 2;
}

//战斗内数据
message BattleData
{
	optional int32 key = 1;
	optional int32 value = 2;
}

message BattleResultQueryRoleOption
{
	optional bool skillDamage = 2[default=false];		//是否统计技能伤害信息
	optional bool impactDamge = 3[default=false];		//是否统计impact伤害信息
	optional bool hitTypeDamage = 4[default=false];		//是否统计hitType伤害信息

	optional bool skillHeal = 5[default=false];			//是否统计技能治疗量
	optional bool impactHeal = 6[default=false];		//是否统计impact治疗量
	optional bool hitTypeHeal = 7[default=false];		//是否统计hitType治疗量
}

message BattleResultQueryOption
{
	optional bool redStatist = 1[default=false];	//是否有红方统计信息，蓝方默认统计
	optional bool roleBasics = 2[default=false];	//是否有角色信息，如果需要查询剩余血量等信息，需要开启

	optional BattleResultQueryRoleOption blueRoleOpts = 3;	//是否蓝方详细信息，一般不需要开启
	optional BattleResultQueryRoleOption redRoleOpts = 4;	//是否有红方详细信息，一般不需要开启

	optional bool blueKill = 5[default=false];		//是否统计蓝方击杀，需要查询击杀信息时开启，开启后自动开启角色信息
	optional bool redKill = 6[default=false];		//是否统计红方击杀，同上
}

message BattleStatist_RoleBasic
{
	optional int32 queryId = 1;			//用来查询的唯一id

	optional int32 roleBaseId = 2;
	optional int32 cardId = 3;
	optional int32 monsterId = 4;
	optional int32 side = 5;
	optional int32 hp = 6;
	optional int32 maxHp = 7;
}

message BattleStatist_KV
{
	optional int32 id = 1;
	optional int64 value = 2;
}

message BattleStatist_Role
{
	optional int32 queryId = 1;						//关联的RoleBasic


	optional int32 actCount = 2;					//行动次数
	optional int64 totalDamage = 3;					//总伤害量
	optional int64 totalHeal = 4;					//总治疗量
	optional int64 maxDamage = 5;					//最高伤害

	repeated BattleStatist_KV skillDamages = 6;		//技能伤害统计
	repeated BattleStatist_KV skillHeals = 7;		//技能治疗统计

	repeated BattleStatist_KV impactDamages = 8;	//impact伤害统计
	repeated BattleStatist_KV impactHeals = 9;		//impact治疗统计

	repeated BattleStatist_KV hitTypeDamages = 10;		//hitType伤害统计
	repeated BattleStatist_KV hitTypeHeals = 11;		//hitType治疗统计

	optional int32 deadRound = 12;		//死亡回合数

}

message BattleStatist_Total
{
	optional int64 totalDamage = 1;
	optional int64 totalHeal = 2;
	optional int64 maxDamage = 3;

	optional int64 maxDamageUnclamp = 5;
	optional int32 deadCount = 6;
}

//最终的战斗结果，客户端战斗会上报，服务器根据配置决定是否使用，还是自己重现
message BattleResult
{
	optional int32 winSide = 1;
	repeated int32 collectedPreviewDropIds = 2;  //上报服务器，打到的掉落物（胜利的话，这个字段无意义）
	
	optional int32 seed = 3;		//最终种子
	optional int32 retHash = 4;		//结果Hash值

	repeated BattleData datas = 5;  //自定义战斗数据记录，非通用的战斗数据，记录在这里

	optional int32 roundCount = 6;	//总回合数

	//基础统计数据，红方可能空
	optional BattleStatist_Total blueStatist = 7;
	optional BattleStatist_Total redStatist = 8;
	
	repeated BattleStatist_RoleBasic roles = 9;  	//参与战斗的所有人员信息,开战后,如果不统计角色信息，这里是空

	repeated BattleStatist_Role blueRoleStatics = 11; 	//针对角色的统计信息,如果不统计角色信息，这里是空
	repeated BattleStatist_Role redRoleStatics = 12;	//针对角色的统计信息,如果不统计角色信息，这里是空

	repeated BattleStatist_KV blueKillStatics = 13;		//击杀信息，key被击杀者，value是击杀者
	repeated BattleStatist_KV redKillStatics = 14;		//击杀信息，key被击杀者，value是击杀者
}

//战斗指令
message BattleCmd
{

	required int32 type = 1;
	required int32 userObjId = 2;

	optional PlayerUseSkillCmd useSkillCmd = 3;
	optional SkipCmd skipCmd = 4;
	optional HeroActCmd heroActCmd = 5;
	optional SetAITarget setAITarget = 6;
	optional SetAutoCmd setAuto = 7;
}

message BattleCmdMsg
{
	repeated BattleCmd cmds = 1;
}

message PlayerUseSkillCmd
{
	optional int32 roleID = 1;
	optional int32 skillSelected = 2;
	optional int32 targetSelected = 3;
}

message HeroActCmd
{
	optional int32 side = 1;
}

//跳过当前回合
message SkipCmd
{
	optional int32 roleID = 1;
	optional bool autoUseSkill = 2;
}

message SetAITarget
{
	optional int32 targetId = 1;
}

//设置自动，主角需要指定是否处于自动中，触发自动AI
message SetAutoCmd
{
	optional bool auto = 1;
}


//两种方案
//1.记录所有的操作(cmd)，然后重演，存储更少，实现略费劲，表配置变化后，录像就会失效(帧同步)
//2.记录所有的事件(event)，然后重播，存储很多，实现简单(状态同步)
//....

message VersionInfo
{
	optional int32 gameVersion = 1;
	optional int32 programVersion = 2;
	optional int32 clientUpdateVersion = 3;
	optional int32 privateResourceVersion = 4;

	optional int32 tableVersion = 5; 	//配置表版本号
	optional int32 luaVersion = 6;		//脚本版本号
}

message BattleMsgWithTimestamp
{
	optional BattleMsg msg = 1;
	optional float time = 2;
}

//战斗记录（帧同步方案，战斗重演，战斗验证）
message BattleRecord
{
	optional VersionInfo versionInfo = 1;
	optional BattleResult result = 2; 			//最终战斗结果
	repeated CmdRecord cmdRecords = 3;			//输入数据

	optional BattleInitData initData = 4;		//可能空
	optional int32 seed = 5;
	optional int32 battleId = 6;
	repeated BattleMsgWithTimestamp events = 7;			//全部战斗事件，可能空
	optional int32 battleType = 8;			//战斗类型
}

//操作
message CmdRecord
{
	optional int32 tick = 1;
	optional int32 state = 2;
	optional BattleCmd cmd = 3;
}

message CmdRecordList
{
	repeated CmdRecord records = 1;
}

message BattleSimulateData
{
	optional BattleInitData initData = 1;

	optional int32 battleId = 3;	//战斗表格id
	optional int32 battleSeed = 4;	//种子

	repeated CmdRecord cmds = 5;
}

message BattleDebug
{
	optional bool nospiritChange = 1;
	optional bool noskillLimit = 2;
	optional int32 startEnv = 3;
	optional int32 startSpirit = 4;
	optional bool nohpChange = 5;
}

//战斗出场人物信息
// message WaveInitData
// {
// 	enum WaveType
// 	{
// 		ByRoles = 1;
// 		ByWaveId = 2;
// 	}
// 	optional WaveType waveType = 1;
// 	repeated RoleInitData roles = 2;
// 	optional int32 battleWaveId = 3;
// }

// message BattleWaveInfo
// {
// 	repeated RoleInitData blues = 1;
// 	repeated RoleInitData reds = 2;
// 	repeated BattleDropByWave drops = 3;
// 	repeated WaveInitData redWaves = 4;
// }

message WaveRoleData
{
	optional int32 waveIndex = 1;
	repeated RoleInitData roles = 2;
}

message WaveDropData
{
	optional int32 waveIndex = 1;
	repeated BattleDropItemList drops = 2;
}

message BattleCost
{
	optional int32 costType = 1; // generilized item id
	optional int32 costValue = 2;
}

message BattleCosts
{
	repeated BattleCost battleCosts = 1;
}

message BattleInitData
{
	//最大波数
	optional int32 waveMax = 1;
	//蓝方上场角色
	repeated WaveRoleData blues = 2;
	//红方上场角色
	repeated WaveRoleData reds = 3;
	//掉落物
	repeated WaveDropData drops = 4;

	//蓝方额外增益buff
	repeated int32 blueImpacts = 5;
	//红方额外增益buff
	repeated int32 redImpacts = 6;

	optional BattleResultQueryOption queryOpts = 7;

	//激活战斗喊话
	optional bool enableBubble = 8;
}

//测试战斗,直接创建某场战斗
message CG_TEST_ASK_ENTER_BATTLE
{
	optional int32 battleId = 1;
	optional bool isAtServer = 2;
	optional bool isStory = 3;
}

message GC_TEST_BATTLE_FINISH
{
	optional int32 winSide = 1;
}

//进入战斗
message GC_ENTER_BATTLE
{
	enum BattleType
	{
		Client = 1;
		ServerSingle = 2;
		MultiPlayer = 3;
		Replay = 4;
	}
	optional int32 battleId = 1;	//战斗表格id
	optional int32 battleSeed = 2;	//种子
	optional int32 id = 3;			//战斗id
	optional BattleType battleType = 4;	//

	optional BattleInitData initData = 5;	//客户端战斗，需要附带的战斗数据

	repeated uint64 cardGuids = 6;	//出战的卡牌数据
	optional int32 heroId = 7;		//当前出战的主角
	optional int32 side = 8;		//属于那一方
	optional int32 userObjId = 9;	//玩家的id标示，不是guid，属于战斗分配给玩家，主要是为了方便统一客户端、服务器战斗。对于服务器战斗，并不信任客户端回传的id
	repeated int32 validPosSet = 10; //可以上卡的位置
	optional int32 battleRetType = 11; //战斗逻辑目的（区分这场战斗时哪个功能，和服务器的BattleRetType对应）
	optional int32 waveMax = 12;   	//波次(显示用)
	optional bool isReEnter = 13;  	//是否是重连进入
	optional bool isHeroValid = 14;		//是否可以换主角
	optional int32 quitDelay = 15; 	//退出延迟，多久后可退出
	optional int32 forceHero = 16[default = -1];  //限定主角
}

//客户端战斗结束
message CG_CLT_BATTLE_FINISH
{
	optional int32 id = 1;
	optional BattleRecord record = 2;
}

//请求退出
message CG_ASK_QUIT_BATTLE
{
	optional int32 id = 1;
}

//调整阵容
message CG_CHANGE_CARD
{
	optional int32 id = 1;
	optional int32 battlePos = 2;   //站位
	optional uint64 cardGuid = 3;		//上阵的卡
	optional int32 heroId = 4;	//切换的是主角
}

//准备
message CG_BATTLE_READY
{
	optional int32 id = 1;
}

//发生战斗指令
message CG_SEND_BATTLE_INPUT
{
	optional int32 id = 1;
	optional BattleCmd cmd = 2;
}

//请求主角行动
message CG_REQ_HERO_ACT
{
	optional int32 id = 1;
}

message GC_HERO_ACT_EVENT
{
	optional int32 side = 1;
	optional int32 index = 2;
}

//战斗事件
message GC_BATTLE_EVENTS
{
	optional BattleMsg msg = 1;
}

message ChangeCardInfo
{
	optional RoleInitData initData = 1;		//客户端战斗时，这个字段才有值

	optional uint64 cardGuid = 2;
	optional uint64 oldCardGuid = 3;
	optional int32 heroId = 4;
}

//调整阵容返回
message GC_CHANGE_CARD_RET
{
	repeated ChangeCardInfo infos = 1;
}

message BattleDropItem
{
	optional int32 dropItemId = 1;
	optional int32 num = 2;
}

//战斗掉落
message BattleDropItemList
{
	optional int32 previewDropId = 1;
	optional int32 battlePos = 2;
	optional int32 battlePosArea = 3;
	repeated BattleDropItem drops = 4;
}

// message BattleDropByWave
// {
// 	optional int32 waveIndex = 1;
// 	repeated BattleDropItemList all = 2;
// }

message GC_COMMON_BATTLE_FINISH
{
	optional int32 winSide = 1;
	optional int32 id = 2;
}

//战斗重启
message CG_BATTLE_RESUME
{
	optional int32 id = 1;
}

//战斗重新同步
message GC_BATTLE_RESYNC
{
	optional SyncBattleState sync = 1;
}

//客户端战斗时，gm需要压入到客户端的lua中去
message GC_BATTLE_GM
{
	optional string gmstr = 1;
}

//战斗验证失败后，发给客户端的调试消息
message GC_BATTLE_VERIFY_RET
{
	optional BattleRecord serverRecord = 1;
}





//异步PVP客户端数据==========数据库存储 修改需要考虑兼容=================
message _ASYNC_PVP_PLAYER_FOR_CLIENT
{
	optional int32   lv = 1;  
	optional int32   modelId = 2; 
	optional int32   grade = 3;
	optional string  name = 4;  
	optional bool 	 isWin  = 5[default = false];
	optional uint64  guid = 6;
	optional int32   skinId = 7[default=-1];
	optional int32   deyColorId = 8[default=-1];
	optional int32   ornamentEffectId = 9[default=-1];
}



//异步PVP==========数据库存储 修改需要考虑兼容=================
message _DB_ASYNC_PVP_PLAYER_FOR_SERVER
{
	repeated RoleInfo  role = 1;
	repeated int32 battlePos = 2;
	optional _ASYNC_PVP_PLAYER_FOR_CLIENT  clientData = 3;

}

//异步PVP==========数据库存储 修改需要考虑兼容=================
message _DB_ASYNC_PVP_OTHER_INFO
{
	repeated int32   awardedAward = 2;  //已经领取的宝箱
	repeated int32   buffs = 3;  //购买的buff
	optional int32   tokens = 4; //该周获得的代币，周重置
	optional int32   grade  = 5[default = 0]; //玩家评级
	optional int32   weekTokens = 6; //上周的代币数量，可以根据该数判断可以得到的奖励
}


//异步PVP==========数据库存储 修改需要考虑兼容=================
message _ASYNC_PVP_DATA_FOR_SERVER
{
	repeated _DB_ASYNC_PVP_PLAYER_FOR_SERVER players = 1;  //8个玩家数据
	optional _DB_ASYNC_PVP_OTHER_INFO  otherInfo = 2;
}


//异步PVP==========数据库存储 修改需要考虑兼容=================
message _DBASYNC_PVP_ROUNTINE_DATA
{
	repeated _DB_ASYNC_PVP_PLAYER_FOR_SERVER players = 1; 
	optional int32   curIndex = 2;
	optional uint64  totle = 3;
}



message _ASYNC_PVP_DATA_FOR_CLIENT
{
	repeated _ASYNC_PVP_PLAYER_FOR_CLIENT players = 1;  //8个玩家数据
	optional _DB_ASYNC_PVP_OTHER_INFO  otherInfo = 2;

}


message GC_ASYNC_PVP_SYNC
{
	optional _ASYNC_PVP_DATA_FOR_CLIENT  data = 1;
	optional bool						  showEffect = 2[default = false];
}

//投降
message CG_REQ_SURRENDER
{
	
}

//客户端进入战斗场景
message CG_ENTER_BATTLE_SCENE
{
	
}


message GC_BATTLE_ROON_BATTLE_TIMES
{
	optional int32   battleTimes = 1;
	optional int32   curBattleTimes = 2;
	optional bool    need2Punish = 3;
}

//同步数据返回
message GC_BATTLE_PULL_SYNC
{
	optional SyncBattleState sync = 1;
}

1. 协议的概念

	

2. b/s c/s

	C/S  优点：   1. 协议选用灵活。  2. 缓存数据。

	     缺点：   1. 对用户的安全构成威胁  2. 开发工作量较大，调试困难


	B/S  优点：   1.  2.  3. 跨平台

	     缺点：   1. http   2.  

	使用场景。

	pad：    iphone 4   ipad 9    mac 11 13

	

3. 分层模型   7   4

	寻路：通过路由表找到下一个路由节点 → 广播一个ARP请求，请求拿到下一个路由节点的Mac地址 → 另一个路由节点拿到ARP请求，
发现该IP地址是自己的，则把ARP请求里填充自己的Mac地址，将包发回到源路由器  → 源路由器拿到ARP包，将IP地址对应的Mac地址填到
以太网帧，将数据包继续投放到网络

4. 协议格式

	数据包基本格式  数-应-传-网-链路

	以太网帧格式  （记录本次转发的源地址和转发目的地址）
                  下一跳Mac(6) 本帧发送Mac(6) 数据 CRC
                  能传输46~1500字节数据（46 <= 应用层数据+传输层报头+IP层报头 <= 1500）

	arp数据包格式 --- arp攻击
                  ARP:借助IP地址请求Mac地址     RARP：借助Mac地址请求IP地址

	IP段格式 -- IP 32 unsigned int（记录数据包的源IP 和 目的主机的IP）
                 4位版本号、4位首部长度、8位生存时间、16位总长度、32位源IP地址和目的IP地址
                 最大携带65535长度的数据。

	TCP/UDP  --  prot 16位源port和目的port  --- 0 ~ 65535  

    IP协议最大携带65535字节数据  而以太网帧协议最大携带1400+字节数据，原因是IP协议需保证兼容性，可以由其他协议代替以太网帧
协议进行工作。

5. NAT映射
作用：一个交换机连接局域网内的N多台机器，每个机器的一个应用程序对应交换机的一个端口号。交换机的IP地址在整个网络大环境内唯一。
举例：交换机在公网内唯一IP 123.24.56.78
NAT映射表：内网192.168.1.35：8000<->自己的10000端口，外部看到的就是123.24.56.78 内网192.168.1.15:8080<->123.24.56.78:8000端口
①我们在主机看到的192.168.1.35是局域网内的IP，存在多个IP相同的终端。   
②一个交换机连接多台终端，数据包出来先进交换机，再进路由器，但是一般路由器具有交换机的功能。
③虽然交换机只有一个公网IP，但是可以下发出来多个私有IP。甚至可以交换机下有二级交换机。
④外网拿到请求后，会认为是交换机的某个端口发出的请求，然后向交换机递送回执包，交换机收到回执包后会做一个NAT映射，将消息递送
给与他连接的对应主机。


打洞机制
提出问题：如果视频聊天数据先到腾讯服务器，再到目标终端，效率会低。应该想办法让两个终端直接通信。
①路由器有一个保护机制，对于陌生的IP，第一次给我发送数据包，我会把这个数据包屏蔽或丢弃。这个时候就需要在两个路由器之间打一个洞。
②腾讯公网服务器被聊天的两个终端所属交换机所熟悉。由腾讯帮助两个交换机进行打洞。
③简单来说在我们登入扣扣的时候，就会访问腾讯服务器，而腾讯服务器也会回一个数据包，这个数据包会携带腾讯服务器公网的IP，
相对于来说服务器的公网IP在A、B那里都是熟悉的IP（就是为了防止陌生IP屏蔽），而服务器借助公网IP帮助A、B完成打洞(打洞就是
实现一种通路)，当它把这个洞打好以后A、B就可以实时通信。打洞是由服务器来完成的，最终的目的就是为了提高数据传输的效率。


总结：公-公 直接访问；   公-私 NAT映射； 私-公 NAT映射； 私-私 NAT映射+打洞机制。

6. 套接字
作用为在网络环境中唯一标识一个进程。本质是文件，行为类似管道。

	1. 成对出现。

	2. bind  IP+port

	3. 一个fd对应两个buf。一个缓存数据读入，一个负责数据写出。

0x12345678 高位->低位，1000较1003为低地址
大端法：低址存高位（例：1000-12，1001-34，1002-56，1003-78）
小端法：低存低（例：1000-78，1001-56，1002-34，1003-12）

7. TCP  

	预备知识。
                           
	   以往转换：	"192.168.1.24"(const char*) --》unsigned int（主机字节序） -》 htonl() -》 网络字节序

	   现在一步到位：	10101010101001  -->　１０１０１０１０１０１００１０１
	
	 (const char* -> 网络)	192.168.1.24 ------------------> 网络字节序  inet_pton();

	(网络字节序 -> const char*)网络字节序 ------------------> 点分十进制字符串  inet_ntop();

      历史遗留问题：早期的sockaddr（废弃） 和 sockaddr_in（实际用）
	struct sockaddr_in addr;
	
	addr.sin_family = AF_INET/AFINET6;
	addr.sin_port = htons/ntohs;           (注意字节序转换)
	addr.sin_addr.s_addr = htonl; ntosl;  inet_pton  inet_ntop;    （字节序转换）

      相关函数	
	bind( , （struct sockaddr *）&addr);  如果不调用会自动分配

	accept();

	connect();

C/S模型
	server.c

		1. socket()  建立套接字

		2. bind() 绑定IP 端口号  (struct sockaddr_in addr 先进行赋值)

		3. listen() 指定最大同时发起连接数

		4. accept()  阻塞等待客户端发起连

		5. read()
		
		6. 小--大

		7. write 给 客户端

		8. close();

	client.c

		1. socket();

		2. bind();  可以依赖“隐式绑定”

		3. connect();发起连接

		4. write();
		
		5. read();

		6. close();